# 项目名称：直播辩论管理

前端演示地址：http://118.31.61.86:8082/

## 技术栈说明
### 一、后端框架
- 核心框架：Flask 2.3.3       选Flask主要是因为它轻量，写代码不用绕弯子，开发起来快。对于这种需要快速搭建Mock服务、适配前端联调的直播平台后端来说，特别合适
- 网关框架：Express.js        它在 Node.js 生态里成熟稳定，处理 HTTP 请求和路由转发很顺手。它支持 WebSocket，能实现直播状态实时推送、票数同步这些实时功能，刚好满足直播场景的需求。
- 跨域处理：Flask-CORS 4.0.0  前端开发的时候，经常会遇到跨域访问的问题，浏览器直接拦着不让请求。用这个Flask-CORS就能解决
- 生产部署：Gunicorn 21.2.0   Gunicorn 是个高性能的服务器，能替代 Flask 自带的开发服务器，处理并发请求的能力更强，上线部署用它，服务能更稳定

### 二、Mock 数据生成方案        
- 后端 Mock 工具：Faker 20.1.0  它能生成唯一 ID、有效图片链接（头像、直播封面）、随机句子（直播标题）这些，直接就能用在接口返回里，不用自己手动造数据。
- 网关内置 JSON 模拟            网关里直接写了固定的 JSON 模拟数据，比如直播流列表、辩题信息、AI 辩论内容这些。
- 代码逻辑模拟动态数据           靠代码逻辑生成动态 Mock 数据。比如用 random 库随机生成直播状态（未开始 / 直播中 / 已结束）、观看人数、点赞数，让数据看起来更真实
- 数据格式统一                  不管是后端还是网关，返回的数据格式都统一了，都是 “状态码 + 提示信息 + 业务数据” 的结构，前端解析起来不用来回调整。

### 三、部署平台与方式
- 采用阿里云云服务器进行部署
- 通过阿里云控制台 Workbench 登录服务器后，初始化系统环境：更新系统并安装基础工具（Git、Python3、pip3）；升级 pip，验证工具版本（确保 Python、Git 可正常调用）
- 后端（Flask）部署：通过 Git 拉取项目仓库，基于requirements.txt安装 Flask、Gunicorn 等依赖；用 Gunicorn 以生产模式启动后端，监听127.0.0.1:5000端口，后台运行并输出日志
- 网关（Express）部署：通过 NVM 安装 Node.js 16；编辑网关server-mode.node.js，将请求转发至后端；安装网关依赖及 PM2，用 PM2 启动网关服务
前端部署（Nginx）：配置开机自启，作为静态资源服务与反向代理；修改nginx.conf，配置前端路由刷新规则、API 请求转发至网关3000端口、WebSocket（直播功能）转发。

## 项目结构与接口说明
一、后端目录结构
- .idea/：PyCharm 项目配置文件夹，包含调试配置、代码格式化规则等 IDE 相关设置。
- venv/： Python 虚拟环境文件夹，隔离项目依赖，内置项目所需的 Flask、Faker 等第三方库。
- app.py：核心业务文件，包含 Flask 应用初始化、跨域配置、所有 API 接口实现及服务启动逻辑。
- requirements.txt：依赖管理文件，记录项目所需第三方库及具体版本，用于快速搭建开发环境。

### 二、主要接口（路径、方法、返回格式）
    功能	  方法	     路径	                            描述	                                      返回格式
- 服务健康检查  GET	 /api/health	               验证后端服务是否正常运行	              {"code": 200, "message": "success", "data": {"service": "live-backend", "status": "running", "timestamp": "时间字符串"}}
- 获取用户信息	 GET	 /api/user/info	             获取当前登录用户的基本信息（Mock 数据）	{"code": 200, "message": "获取用户信息成功", "data": {"userId": "UUID", "username": "用户名", "nickname": "昵称", "avatar": "头像链接", "email": "邮箱", "phone": "手机号", "gender": 0/1/2, "level": 等级，"createTime": "创建时间"}}
- 获取直播列表	 GET	 /api/live/list	             分页获取直播列表	                    {"code": 200, "message": "获取直播列表成功", "data": {"records": [直播数据数组], "total": 总条数，"page": 当前页，"size": 每页条数，"pages": 总页数}}
- 创建直播	     POST  /api/live/create	           接收直播标题、分类参数，创建直播记录	  {"code": 200, "message": "直播创建成功", "data": {"liveId": "UUID", "title": "直播标题", "category": "分类", "createTime": "创建时间", "status": 0}}
- 获取直播详情	 GET	 /api/live/detail/<live_id>	 根据直播 ID 获取单场直播的详细信息	    {"code": 200, "message": "获取直播详情成功", "data": {"liveId": "传入的直播 ID", "title": "直播标题", "anchorName": "主播名", "coverImage": "封面链接", "viewCount": 观看数，"status": 0/1/2, "startTime": "开始时间", "description": "直播描述", "tags": ["标签 1", "标签 2"]}}

## 项目开发过程笔记
### 一、项目实现思路
- 开发流程是 “先拆模块→再联调→最后部署”：先分别完成后端接口、网关转发逻辑、前端页面开发，本地联调验证各模块衔接，最后部署到阿里云服务器并验证全链路可用性。
- 后端用 Flask 框架快速搭建 API 服务，负责处理直播管理、用户信息、数据存储等核心业务；网关基于 Express.js 实现，承担请求转发、跨域处理和部分 Mock 数据返回的职责；实时互动功能通过 WebSocket 建立长连接，实现弹幕、点赞、礼物消息的实时推送。
- 数据层面，后端用 Faker 生成符合中文场景的 Mock 数据，涵盖用户信息、直播列表、互动数据等，同时统一接口返回格式，确保前后端联调顺畅

### 二、遇到的问题与解决方案
GitHub 子文件夹显示异常
问题：项目推送到 GitHub 后，gateway/frontend文件夹显示为 “灰色不可点击”；
解决：删除子文件夹内的独立.git隐藏文件，重新提交代码并推送，子文件夹恢复正常访问。
部署后前端刷新 404
问题：服务器部署前端后，首次加载正常，刷新页面提示 404；
解决：在 Nginx 配置中添加try_files $uri $uri/ /index.html;规则，将路由请求重定向到index.html。
前端请求后端跨域报错
问题：本地开发时，前端直接调用后端接口，浏览器提示跨域限制；
解决：在后端通过flask-cors插件配置跨域允许，同时在前端开发服务器配置接口代理，临时绕过跨域限制。

### 三、本地联调的经验
- （1）提前同步后端、前端、网关的依赖版本（比如后端 Python 版本、前端 Node 版本），避免因依赖差异导致本地运行报错。
- （2）服务启动顺序按 “后端→网关→前端” 的顺序启动服务。
- （3）前端利用浏览器 “Console” 打印接口请求参数、响应结果，快速定位传参 / 格式错误。
- （4）本地联调时，前端直接请求后端 / 网关常出现跨域报错，可通过：后端配置 CORS 跨域允许（如 Flask 安装flask-cors插件）；前端本地开发服务器配置代理（如 Vite 的proxy配置，将/api代理到网关地址）。

### 四、部署步骤与踩坑记录
1、**部署步骤**
- （1）服务器环境初始化：通过阿里云控制台 Workbench 完成服务器远程登录；安装 Git、Python3、pip3 等核心工具，升级 pip 至最新版本，验证各工具版本可正常调用
- （2）后端（Flask）部署：借助 Git 拉取项目仓库代码，进入后端（backend）目录；基于项目的 requirements.txt 文件，安装 Flask、Gunicorn 等后端依赖；使用 Gunicorn 以生产模式启动后端服务，绑定 端口，配置后台运行并将日志输出至指定文件，保障服务持续可用。
- （3）网关（Express）部署：通过 NVM 安装 Node.js 16 版本（适配网关依赖）；进入网关（gateway）目录，编辑转发配置文件将请求转发地址指向后端 127.0.0.1:5000。
- （4）前端（Nginx）部署：安装 Nginx 并设置开机自启，编辑 nginx.conf 配置文件：配置前端静态资源根路径、解决前端路由刷新 404 问题，同时将 API 请求转发至网关 3000 端口、WebSocket（直播功能）请求也转发至网关对应端口；启动 Nginx 服务。
- （5）网络与验证：在阿里云 ECS 安全组中开放 80（HTTP）、3000（网关）等项目所需端口；本地浏览器访问服务器公网 IP，验证前端页面加载、接口数据请求、直播功能等核心功能是否正常。
2、**踩坑记录**
（1）**环境版本兼容问题**
- 问题：网关启动报错，排查发现 Node.js 版本过低，与网关依赖包不兼容；
- 解决：通过 NVM 安装指定的 Node.js 16 版本，切换版本后重新安装依赖，网关正常启动。
（2）**端口与网络访问问题**
- 问题：浏览器访问服务器 IP 无法加载前端页面，接口请求提示连接失败；
- 解决：检查阿里云安全组是否开放 80 端口，未开放则补充配置；验证 Nginx、网关、后端服务端口是否被占用，确保各服务端口互不冲突；检查 Nginx 配置中转发地址是否写错，修正后重启 Nginx。
（3）**Git 相关部署问题**
- 问题：子文件夹（gateway/frontend）在 GitHub 显示异常；
- 解决：删除子文件夹内的独立.git 文件夹，重新提交推送代码，解决子文件夹无法正常显示的问题。
（4）**进程守护与日志排查问题**
- 问题：服务器重启 / 网络波动后，后端 / 网关服务自动停止；
- 解决：后端使用 nohup+Gunicorn、网关使用 PM2 管理进程，确保服务后台持续运行；同时配置日志输出，服务异常时可通过日志快速定位报错原因。

## 个人介绍
- 主语言是 Python，深耕数据分析全流程，同时熟练掌握 SQL 查询与 Linux 系统操作。
- 在技术学习和项目实践中，我始终抱着 “先拆后拼、边做边调” 的思路：从基础的 Python、JavaScript 语法入手，逐步掌握 Flask 后端框架、Express 网关开发和前端开发技能，形成 “后端 + 网关 + 前端” 的全栈技术视野。
- 除了技术实践，我还注重数据思维的培养，能运用数据分析方法梳理项目问题、优化流程。做事踏实细心，遇到复杂问题会拆解成小步骤逐一突破，喜欢在解决问题后总结经验，形成可复用的方法。



